# 오픈소스SW 과제2, 학번 20205089, 이름 김형준

## 1. 리눅스 명령어

### 1. top 명령어
1. **시스템의 상태를 전반적으로 가장 빠르게 파악 가능 (CPU, Memory, Process)**
2. **옵션 없이 입력하면 interval 간격(기본 3초)으로 화면을 갱신하며 정보를 보여줌**
3. **top 실행 전 옵션**
 - 순간의 정보를 확인하려면 –b 옵션 추가(batch 모드)
 - -n : top 실행 주기 설정(반복 횟수)
4. **top 실행 후 명령어**
 - shift + p : CPU 사용률 내림차순
 - shit + m : 메모리 사용률 내림차순
 - shift + t : 프로세스가 돌아가고 있는 시간 순
 - k : kill. k 입력 후 PID 번호 작성. signal은 9
 - k : kill. k 입력 후 PID 번호 작성. signal은 9
 - a : 메모리 사용량에 따라 정렬
 - b : Batch 모드로 작동
 - 1 : CPU Core별로 사용량 보여줌
5. **ps와 top의 차이점**
 - ps는 ps한 시점에 proc에서 검색한 cpu 사용량
 - top은 proc에서 일정 주기로 합산해 cpu 사용율 출력
6. **top –b –n 1**

!<img src="https://user-images.githubusercontent.com/106909588/172050535-e494437f-6845-45c6-892f-b7a50d0700eb.png" width="640" height="480">

 - 0 : 0분전에 서버가 구동
 - load average : 현재 시스템이 얼마나 일을 하는지를 나타냄. 3개의 숫자는 1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수. CPU 코어수 보다 적으면 문제 없음
 - Tasks : 프로세스 개수
 - KiB Mem, Swap : 각 메모리의 사용량
 - PR : 실행 우선순위
 - VIRT, RES, SHR : 메모리 사용량 => 누수 check 가능
 - S : 프로세스 상태(작업중, I/O 대기, 유휴 상태 등)

7. **VIRT, RES, SHR**
 - VIRT
   - 프로세스가 사용하고 있는 virtual memory의 전체 용량
   - 프로세스에 할당된 가상 메모리 전체
   - SWAP + RES
 - RES
   - 현재 프로세스가 사용하고 있는 물리 메모리의 양
   - 실제로 메모리에 올려서 사용하고 있는 물리 메모리
   - 실제로 메모리를 쓰고 있는 RES가 핵심!
 - SHR
   - 다른 프로세스와 공유하고 있는 shared memory의 양
   - 예시로 라이브러리를 들 수 있음, 대부분의 리눅스 프로세스는 glibc라는 라이브러리를 참고하기에 이런 라이브러리를 공유 메모리에 올려서 사용
8. **Memory Commit**
 - 프로세스가 커널에게 필요한 메모리를 요청하면 커널은 프로세스에 메모리 영역을 주고 실제로 할당은 하지 않지만 해당 영역을 프로세스에게 주었다는 것을 저장해둠
 - 이런 과정을 Memory commit이라 부름
 - 왜 커널은 프로세스의 메모리 요청에 따라 즉시 할당하지 않고 Memory Commit과 같은 기술을 사용해 요청을 지연시킬까?
   - fork()와 같은 새로운 프로세스를 만들기 위한 콜을 처리해야 하기 때문
   - fork() 시스템 콜을 사용하면 커널은 실행중인 프로세스와 똑같은 프로세스를 하나 더 만들고, exec() 시스템 콜을 통해 다른 프로세스로 변함. 이 때 확보한 메모리가 쓸모               없어질 수 있음
   - COW(Copy-On-Write) 기법을 통해 복사된 메모리 영역에 실제 쓰기 작업이 발생한 후 실질적인 메모리 할당을 진행
9. **프로세스 상태**
 - *SHR 옆에 있는 S 항목으로 볼 수 있음*
   - D : Uninterruptiable sleep. 디스크 혹은 네트워크 I/O를 대기
   - R : 실행 중(CPU 자원을 소모)
   - S : Sleeping 상태, 요청한 리소스를 즉시 사용 가능
   - T : Traced or Stopped. 보통의 시스템에서 자주 볼 수 없는 상태
   - Z : zombie. 부모 프로세스가 죽은 자식 프로세스



### 2. ps 명령어
1. **Process Status의 약어를 이름으로 사용한 ps 명령어를 사용하면 현재 구동 중인 프로세     스 정보를 확인할 수 있습니다. 명령어와 함께 사용되는 주요 옵션들은 다음과 같습니다.**
 - -e: 현재 사용자뿐만 아니라 다른 사용자들이 구동시킨 모든 프로세스를 보여줍니다. (즉, -e 옵션이 없다면 ps 명령어는 현재 사용자(Shell)이 실행 중인 프로세스만 보여줍니다.)
 - -f: 보다 상세한 정보를 보여줍니다. (Full format)
 - -l: -f 보다 더 상세한 정보를 보여줍니다. (Long format)
2. **ps -efl 명령어를 통해 출력되는 결과의 각 필드의 의미는 다음과 같습니다. (실행 환경마     다 필드의 이름 혹은 출력 순서가 다를 수 있습니다.)**
![ps](https://user-images.githubusercontent.com/106909588/172051330-e491c035-485b-48f6-94b8-750b89b67270.png)

3. **F: 프로세스 플래그**
 - 4: used super-user privileges
 - 1: forked but didn't exec
 - 5: 4 & 1 플래그에 모두 해당하는 경우
 - 0: 어떤 플래그에도 해당하지 않는 경우
4. **S: 프로세스의 현재 상태**
 - R: 실행 중 혹은 실행될 수 있는 상태
 - S: 대기 상태 (약 20초 이상)
 - I: 대기 상태 (약 20초 이하)
 - T: 작업 제어에 의해 정지된 상태
 - D: 디스크 관련 대기 상태
 - P: 페이지 관련 대기 상태
 - X: 메모리 확보를 위한 대기 상태
 - >: 인위적으로 우선 순위가 높아진 상태
 - Z: 좀비 프로세스
   - UID: 프로세스를 실행시킨 사용자 ID
   - PID: 프로세스에 부여된 ID
   - PPID: 프로세스의 부모 프로세스 ID (Parent Process ID)
   - C: CPU 사용량(%)
   - PRI: 프로세스 우선순위
   - NI: 프로세스의 CPU 자원 사용 우선순위 (Nice)
   - ADDR: 프로세스의 메모리 주소
   - SZ: 가상 메모리 사용량
   - STIME: 프로세스 시작 시간
   - TTY: 프로세스가 실행된 터미널의 종류와 번호
   - TIME: 프로세스에 의해 사용된 CPU 시간
   - CMD: 실행된 프로세스의 이름 혹은 실행된 명령
### 3. jobs 명령어
1. **리눅스 명령어 jobs는 작업이 중지된 상태, 백그라운드로 진행 중인 작업 상태, 변경 되었     지만 보고되지 않은 상태 등을 표시하는 명령어다.**
2. **경로 : 내부 명령어**
3. **사용법 : jobs [옵션] [job ID], jobs -x command [args]**
4. **옵션**
  - -l
    - 프로세스 그룹 ID를 state 필드 앞에 출력
  - -n
    - 프로세스 그룹 중에 대표 프로세스 ID를 출력
  - -p
    - 각 프로세스 ID에 대해 한 행씩 출력
  - command
    - 지정한 명령어를 실행 
5. **상태**
 - Running
   - 작업이 일시 중단되지 않았고 종료하지 않고 계속 진행 중임
 - Done
   - 작업이 완료되어 0을 반환하고 종료 했음을 의미
 - Done(code)
   - 작업이 정삭적으로 완료되었으며, 0이 아닌 코드를 반환 했음을 의미
 - Stopped
   - 작업이 일시 중단
 - Stopped(SIGTSTP)
   - SIGTSTP 신호가 작업을 일시 중단
 - Stopped(SIGSTOP)
   - SIGSTOP 신호가 작업을 일시 중단
 - Stopped(SIGTTIN)
   - SIGTTIN 신호가 작업을 일시 중단
 - Stopped(SIGTTOU)
   - SIGTTOU 신호가 작업을 일시 중단

### 4. kill 명령어

## 2. vim 에디터 매크로 사용방법
